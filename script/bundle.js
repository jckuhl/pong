/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./script/pong.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./script/easycanvas.js":
/*!******************************!*\
  !*** ./script/easycanvas.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * @module EasyCanvas\n * @author Jonathan Kuhl <jckuhl87@gmail.com>\n * @file A library for simplifying canvas\n * @copyright Copyright 2018\n */\n\n/**\n * @class\n * @memberof module:EasyCanvas\n */\n\n\n\nmodule.exports = {\n\n    distance: function(x, y, dx, dy) {\n        return Math.sqrt(\n            Math.pow(((dx - x), 2) + ((dy - y), 2))\n        );\n    },\n\n    /**\n     * Clears all contexts in width X, Y\n     * @param {number} w - Width of the area being cleared\n     * @param {number} l - Length of the area being cleared\n     * @param {CanvasRenderingContext2D} args - The contexts being cleared\n     */\n    clearAll: function(w, l, ...args) {\n        for (let arg of args) {\n            arg.clearRect(0, 0, w, l);\n        }\n    },\n\n    /**\n     * Draws a borderless circle\n     * @param {CanvasRenderingContext2D} context - The rendering context for the canvas\n     * @param {number} x - X position\n     * @param {number} y - Y position\n     * @param {number} radius - Circle's radius\n     * @param {string} color - Color value\n     */\n    drawCircleNoBorder: function(context, x, y, radius, color) {\n        context.beginPath();\n        context.arc(x, y, radius * 2, 0, Math.PI * 2);\n        context.fillStyle = color;\n        context.fill();\n        context.closePath;\n    },\n\n    /**\n     * Draws a borderless rectangle\n     * @param {CanvasRenderingContext2D} context - The rendering context for the canvas\n     * @param {number} x - X position\n     * @param {number} y - Y position\n     * @param {number} w - Width\n     * @param {number} l - Length\n     * @param {string} color - Color value\n     */\n    drawRectNoBorder: function(context, x, y, w, l, color) {\n        context.beginPath();\n        context.rect(x, y, w, l);\n        context.fillStyle = color;\n        context.fill();\n        context.closePath();\n    },\n\n    /**\n     * Draws text on a canvas\n     * @param {CanvasRenderingContext2D} context - The rendering context for the canvas\n     * @param {object} props - Text properties\n     * @prop {string} string - Text to be displayed\n     * @prop {number} fontsize - Font size, like 18 for 18pt\n     * @prop {string} face - Font face\n     * @prop {string} [color=\"black\"] - Text color, defaults to black\n     * @prop {string} [just=\"center\"] - Justification, defaults to left\n     * @prop {number} x - X position\n     * @prop {number} y - Y position\n     */\n    drawText: function(context, props = {\n        string: string,\n        fontsize: fontsize,\n        face: face,\n        color: black,\n        just: \"left\",\n        x: x,\n        y: y\n    }) {\n        context.font = this.setFont(props.fontsize, props.face);\n        context.fillStyle = props.color;\n        context.textAlign = props.just;\n        context.fillText(props.string, props.x, props.y);\n    },\n\n    /**\n     * Draws a line\n     * @param {CanvasRenderingContext2D} context - The rendering context for the canvas\n     * @param {object} props - Line properties\n     * @prop {number} x - start X position\n     * @prop {number} y - start Y position\n     * @prop {number} dx - end X position\n     * @prop {number} dy - end Y position\n     * @prop {number} lineWidth - Line width, defaults to 1\n     * @prop {string} color - Line color, defaults to black\n     */\n    drawLine: function(context, props = {\n        x: x,\n        y: y,\n        dx: dx,\n        dy: dy,\n        lineWidth: 1,\n        color: \"black\"\n    }) {\n        context.beginPath();\n        context.moveTo(props.x, props.y);\n        context.lineTo(props.dx, props.dy);\n        context.lineWidth = props.lineWidth;\n        context.strokeStyle = props.color;\n        context.stroke();\n    },\n\n    /**\n     * Draws a polygon of x sides\n     * @param {CanvasRenderingContext2D} context - The rendering context for the canvas\n     * @param {array} vertexMatrix - Array of objects with properties x and y\n     * @prop {string} color - Line color, defaults to black\n     */\n    drawPolygon: function(context, vertexMatrix) {\n        context.beginPath();\n        for (let i = 0; i < vertexMatrix.length; i++) {\n            context.moveTo(vertexMatrix[i].x, vertexMatrix[i].y);\n            if (i + 1 < vertexMatrix) {\n                context.lineTo(vertexMatrix[i + k].x, vertexMatrix[i + k].y);\n            } else {\n                context.lineTo(vertexMatrix[0].x, vertexMatrix[0].y);\n            }\n        }\n    },\n\n    /**\n     * Sets a font\n     * @param {number} fontsize - Font size, like 18 for 18pt\n     * @param {string} face - Font face\n     * @return {string} - A font face string\n     */\n    setFont: function(fontsize, face) {\n        return `normal ${fontsize}pt ${face}`;\n    },\n\n    /**\n     * Gets the center of the canvas\n     * @param {element} canvas - Canvas element\n     * @return {object} - Returns an object with the x and y values of the center\n     */\n    getCenter: function(canvas) {\n        return {\n            x: canvas.width / 2,\n            y: canvas.height / 2\n        }\n    },\n\n    /**\n     * Gets the corners of the canvas\n     * @param {element} canvas - Canvas element\n     * @return {object} - Returns an object with the top, bottom, left, right corner values\n     */\n    getCornerPositions: function(canvas) {\n        return {\n            top: canvas.getBoundingClientRect().top,\n            bottom: canvas.getBoundingClientRect().bottom,\n            left: canvas.getBoundingClientRect().left,\n            right: canvas.getBoundingClientRect().right\n        };\n    },\n}\n\n//# sourceURL=webpack:///./script/easycanvas.js?");

/***/ }),

/***/ "./script/pong.js":
/*!************************!*\
  !*** ./script/pong.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const EasyCanvas = __webpack_require__(/*! ./easycanvas */ \"./script/easycanvas.js\");\n\n!function () {\n    \n    'use strict';\n\n    const canvas = document.querySelector('#playArea');\n    const ctx = canvas.getContext('2d');\n    const menu = document.querySelector('#menuArea');\n    const menuCtx = menu.getContext('2d');\n    const audio = document.querySelectorAll('audio');\n    const green = '#17700d';\n    const darkGreen = '#0d3f07';\n    const paddleW = 25;\n    const paddleL = 125;\n    const speed = 8;\n    const winningScore = 21;\n    const fontVT323 = 'VT323';\n    const corners = EasyCanvas.getCornerPositions(canvas);\n    const center = EasyCanvas.getCenter(canvas);\n    \n    let aiFlag = false;\n    let paused = false;\n    let playing = false;\n    let activateSpace = false;\n    let ballSpeed = 2;\n    let Paddle1;\n    let Paddle2;\n    let Ball;\n    \n    menu.style.top = corners.top + 'px';\n    menu.style.left = corners.left + 'px';\n    \n    const fontSize = {\n        Lg: 80,\n        Md: 24,\n        Sm: 12\n    };\n  \n    //init coords for paddles and ball\n    const p1Start = {\n        x: 25,\n        y: center.y - (paddleL / 2)\n    };\n  \n    const p2Start = {\n        x: canvas.width - 50,\n        y: center.y - (paddleL / 2)\n    };\n  \n    const ballStart = {\n        x: center.x,\n        y: center.y + 10    //ball has a radius of 10, lower it by 10 to center it\n    };\n  \n    //inclusive random integer generator\n    function random(min, max) {\n        return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n    \n    function negFactor() {\n        let i = random(1, 2);\n        return i === 1 ? 1 : -1;\n    }\n\n    //sets the ball back in the center\n    function resetPos(ball) {\n        ballSpeed = 2;\n        ball.x = ballStart.x;\n        ball.y = ballStart.y; \n        ball.dx = ballSpeed * negFactor();\n        ball.dy = ballSpeed * negFactor();\n    }\n  \n    //paddle constructor\n    class Paddle {\n        constructor(startX, startY) {\n            this.x = startX;\n            this.y = startY;\n            this.movUp = 0;\n            this.movDn = 0;\n            this.score = 0;\n            this.iAmAnAI = false;\n        }\n        drawPaddle() {\n            EasyCanvas.drawRectNoBorder(ctx, this.x, this.y, paddleW, paddleL, green);\n        }\n        aiUpdatePosition(ball) {\n            if (ball.x > center.x + 300) {\n                this.targetY = ball.y;\n                if (this.y + (paddleL / 2) > this.targetY) {\n                    this.y -= 8;\n                    //                    this.movDn = 0;\n                }\n                else {\n                    //                    this.movUp = 0;\n                    this.y += 8;\n                }\n                //this.y += -this.movUp + this.movDn;\n                constrain(this);\n            }\n        }\n\n        updatePosition() {\n            this.y += -this.movUp + this.movDn;\n            constrain(this);\n        };\n    }\n    \n    \n     \n  \n    class Puck {\n        constructor(startX, startY) {\n            this.radius = 10;\n            this.x = startX;\n            this.y = startY;\n            this.color = green;\n            this.dx = ballSpeed * negFactor();\n            this.dy = ballSpeed * negFactor();\n            this.drawBall = () => {\n                EasyCanvas.drawCircleNoBorder(ctx, this.x, this.y, this.radius, this.color);\n            }; //End drawBall()\n            this.glow = () => {\n                this.color = 'lime';\n                setTimeout(() => {\n                    this.color = green;\n                }, 100);\n            }; //end glow()\n            this.isHittingLeftPaddle = () => {\n                return ((this.x - this.radius <= Paddle1.x + paddleW)\n                    && ((this.y >= Paddle1.y)\n                        && (this.y <= Paddle1.y + paddleL - this.radius)));\n            };\n            this.isHittingRightPaddle = () => {\n                return ((this.x + this.radius >= Paddle2.x)\n                    && ((this.y >= Paddle2.y)\n                        && (this.y <= Paddle2.y + paddleL - this.radius)));\n            };\n            this.updatePosition = () => {\n                this.x += this.dx;\n                this.y += this.dy;\n                //if the ball bounces off the top or bottom\n                if (this.y + this.radius >= canvas.height) {\n                    this.dy = -ballSpeed;\n                }\n                if (this.y - this.radius <= 0) {\n                    this.dy = ballSpeed;\n                }\n                //if the ball hits Paddle 1\n                if (this.isHittingLeftPaddle()) {\n                    audio[0].play();\n                    this.dx = ballSpeed;\n                    this.glow();\n                }\n                //if the ball hits Paddle 2\n                if (this.isHittingRightPaddle()) {\n                    audio[1].play();\n                    this.dx = -ballSpeed;\n                    this.glow();\n                }\n                //if the ball hits the left or right\n                //score the game\n                if (this.x - this.radius <= 0) {\n                    resetPos(this);\n                    audio[2].play();\n                    Paddle2.score += 1;\n                }\n                if (this.x + this.radius >= canvas.width) {\n                    resetPos(this);\n                    audio[2].play();\n                    Paddle1.score += 1;\n                }\n            }; //End updatePosition()\n        }\n    }\n  \n    function constrain(paddle) {\n        const constraint = {\n            left: 25,\n            right: canvas.height - paddleL - 25,\n        };\n        if(paddle.y < constraint.left) paddle.y = constraint.left;\n        if(paddle.y > constraint.right) paddle.y = constraint.right;\n    }\n  \n    function drawGameLines() {\n        const lineProps = {\n            x: center.x,\n            y: 0,\n            dx: center.x,\n            dy: canvas.height,\n            lineWidth: 4,\n            color: darkGreen\n        };\n        EasyCanvas.drawLine(ctx, lineProps);\n    }\n  \n    function drawScore() {\n        const fontsize = 64;\n        ctx.font = EasyCanvas.setFont(fontsize, fontVT323);\n        ctx.fillText(`${Paddle1.score}`, canvas.width / 4, fontsize);\n        ctx.fillText(`${Paddle2.score}`, (canvas.width / 4) * 3, fontsize);\n    }\n    \n    function displayMenuText(string, fontsize, x, y, just='center') {\n        const textProps = {\n            string: string,\n            fontsize: fontsize,\n            face: fontVT323,\n            color: green,\n            just: just,\n            x: x,\n            y: y\n        };\n        EasyCanvas.drawText(menuCtx, textProps);\n    }\n\n    function togglePause() {\n        if(!paused) {\n            paused = true;\n            menu.style.display = 'block';\n            menu.style.backgroundColor = 'rgba(0, 0, 0, 0)';\n            displayMenuText('Paused', fontSize.Lg, center.x, center.y);\n            displayMenuText('Hit Esc or Space to continue', fontSize.Md, center.x, center.y + 36);\n        } else {\n            paused = false;\n            menu.style.display = 'none';\n            menu.style.backgroundColor = 'rgba(0, 0, 0, 1)';\n            EasyCanvas.clearAll(canvas.width, canvas.height, menuCtx);\n        }\n    }\n  \n    window.addEventListener('keydown', (e)=> {\n        switch(e.key) {\n        case 'w':\n            if(!Paddle1) break;\n            Paddle1.movUp = speed;\n            break;\n        case 's':\n            if(!Paddle1) break;\n            Paddle1.movDn = speed;\n            break;\n        }\n    });\n  \n    //ugly fix to stop the page from scrolling when [space] is pressed\n    window.addEventListener('keypress', (e)=> {\n        if(e.keyCode === 32) {\n            e.view.event.preventDefault();\n            if(activateSpace) {\n                aiFlag = false;\n                startGame();\n            }\n            if(paused) {\n                togglePause();\n            }\n        }\n    });\n    \n    window.addEventListener('keyup', (e)=> {\n        switch(e.key) {\n        case 'w':\n            if(!Paddle1) break;\n            Paddle1.movUp = 0;\n            break;\n        case 's':\n            if(!Paddle1) break;\n            Paddle1.movDn = 0;\n            break;\n        case 'o':\n            if(!Paddle2) break;\n            Paddle2.movUp = 0;\n            break;\n        case 'l':\n            if(!Paddle2) break;\n            Paddle2.movDn = 0;\n            break;\n        case 'Escape':\n            togglePause();\n            break;\n        }\n    });\n    \n    function startGame() {\n        Paddle1 = new Paddle(p1Start.x, p1Start.y);\n        Paddle2 = new Paddle(p2Start.x, p2Start.y);\n        Ball = new Puck(ballStart.x, ballStart.y);\n        menu.style.display = 'none';\n        EasyCanvas.clearAll(canvas.width, canvas.height, menuCtx);\n        const gameLoop = setInterval(()=> {\n            activateSpace = false;\n            playing = true;\n            EasyCanvas.clearAll(canvas.width, canvas.height, ctx);\n            drawGameLines();\n            drawScore();\n            Ball.drawBall();\n            Paddle1.drawPaddle();\n            Paddle2.drawPaddle();\n            if(!paused) {\n                Paddle1.updatePosition(Ball);\n                Paddle2.aiUpdatePosition(Ball);\n                Ball.updatePosition();\n                ballSpeed += 0.001;\n            }\n            if((Paddle1.score >= winningScore) || (Paddle2.score >= winningScore)) {\n                menu.style.display = 'block';\n                clearInterval(gameLoop);\n                EasyCanvas.clearAll(canvas.width, canvas.height, ctx, menuCtx);\n                const victoryString = Paddle1.score > Paddle2.score ? 'Player 1 wins!' : 'Player 2 wins!';\n                displayMenuText(victoryString, 80, center.x, center.y);\n                displayMenuText('Press Space to play again!', 24, center.x, center.y + 36);\n                activateSpace = true;\n                playing = false;\n            }\n        }, 33);\n    } \n  \n    function drawWelcome() {\n        EasyCanvas.clearAll(canvas.width, canvas.height, ctx, menuCtx);\n        displayMenuText('Welcome to Pong', fontSize.Lg, center.x, center.y);\n        displayMenuText('Hit [Space] to play!', fontSize.Md, center.x, center.y + 36);\n        displayMenuText('Based on the game Pong by Allan Alcorn', fontSize.Sm, canvas.width - 25, canvas.height - 25, 'right');\n        displayMenuText('Written in JavaScript by Jonathan Kuhl', fontSize.Sm, 25, canvas.height - 25, 'left');\n        activateSpace = true;\n    }\n  \n    drawWelcome();\n\n}();\n\n//# sourceURL=webpack:///./script/pong.js?");

/***/ })

/******/ });